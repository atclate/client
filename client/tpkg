#!/usr/bin/ruby -w
##############################################################################
# tpkg package management and deployment tool
##############################################################################

# Ensure we can find tpkg.rb
$:.unshift File.dirname(__FILE__)

require 'optparse'
require 'tpkg'

#
# Parse the command line options
#

@action = nil
@action_value = nil
@debug = false
@prompt = true
@quiet = false
@sudo = true
@lockforce = false
@deploy = false
@deploy_params = ARGV   # hold parameters for how to invoke tpkg on the machines we're deploying to
@deploy_options = {}    # options for how to run the deployer
@servers = nil
@worker_count = 4
@rerun_with_sudo = false

def rerun_with_sudo_if_necessary
  if Process.euid != 0 && @sudo
    warn "Executing with sudo"
    exec('sudo', $0, *ARGV)
  end
end

opts = OptionParser.new
opts.banner = 'Usage: tpkg [options]'
opts.on('--servers', '-s', '=SERVERS', Array, 'Servers to apply the actions to.') do |opt|
  @servers = opt
  @deploy = true
  @deploy_params = @deploy_params - ['--servers', '-s', @servers.join(",")]
end
opts.on('--make', '-m', '=DIRECTORY', 'Make a package out of the contents of the directory') do |opt|
  @action = :make
  @action_value = opt
end
opts.on('--extract', '-x', '=DIRECTORY', 'Extract the metadata for a directory of packages') do |opt|
  @action = :extract
  @action_value = opt
end
opts.on('--install', '-i', '=PACKAGES', 'Install one or more packages', Array) do |opt|
  @rerun_with_sudo = true
  @action = :install
  @action_value = opt
end
opts.on('--upgrade', '-u', '=[PACKAGES]', 'Upgrade one or more packages', Array) do |opt|
  @rerun_with_sudo = true
  @action = :upgrade
  # Since the argument is optional OptionParser will pass true or '' in
  # opt if the option was specified without an argument.  We only want
  # to capture the argument if the user actually passed something.
  if opt != true && opt != ''
    @action_value = opt
  end
end
opts.on('--remove', '-r', '=PACKAGES', 'Remove one or more packages', Array) do |opt|
  @rerun_with_sudo = true
  @action = :remove
  @action_value = opt
end
opts.on('--verify', '-V', '=NAME', 'Verify packages') do |opt|
  @rerun_with_sudo = true
  @action = :verify
  @action_value = opt
end
opts.on('--start', '=NAME', 'Start the init script for the specified package', Array) do |opt|
#  rerun_with_sudo_if_necessary
  @action = :start_init
  @action_value = opt
end
opts.on('--stop', '=NAME', 'Stop the init script for the specified package', Array) do |opt|
#  rerun_with_sudo_if_necessary
  @action = :stop_init
  @action_value = opt
end
opts.on('--restart', '=NAME', 'Restart the init script for the specified package', Array) do |opt|
#  rerun_with_sudo_if_necessary
  @action = :restart_init
  @action_value = opt
end
opts.on('--query', '-q', '=NAME', 'List installed packages') do |opt|
  @action = :query_installed
  @action_value = opt
end
opts.on('--qa', 'List all installed packages') do |opt|
  @action = :query_installed
end
opts.on('--qi', '=NAME', 'Info for installed packages') do |opt|
  @action = :query_info
  @action_value = opt
end
opts.on('--ql', '=NAME', 'List files in installed packages') do |opt|
  @action = :query_list_files
  @action_value = opt
end
opts.on('--qf', '=NAME', 'List the package that owns a file') do |opt|
  @action = :query_who_owns_file
  @action_value = opt
end
opts.on('--qv', '=[NAME]', 'List available packages') do |opt|
  @action = :query_available
  # Since the argument is optional OptionParser will pass true or '' in
  # opt if the option was specified without an argument.  We only want
  # to capture the argument if the user actually passed something.
  if opt != true && opt != ''
    @action_value = opt
  end
end
opts.on('--qr', '=NAME', 'List installed packages that require package') do |opt|
  @action = :query_requires
  @action_value = opt
end
opts.on('--qd', '=NAME', 'List the packages that package depends on') do |opt|
  @action = :query_depends
  @action_value = opt
end
opts.on('--dw', '=Integer', 'Number of workers for deploying. Only meaningful when using the -s option') do |opt|
  @worker_count = opt
  @deploy_params = @deploy_params - ['--dw', @worker_count]
end
opts.on('-n', '--no-prompt', 'No confirmation prompts regarding file conflicts or package removals') do |opt|
  @prompt = opt
  Tpkg::set_prompt(@prompt)
end
opts.on('--quiet', 'Reduce or eliminate informative but non-essential output') do |opt|
  @quiet = opt
end
opts.on('--no-sudo', 'No calls to sudo for operations that might need root privileges') do |opt|
  @sudo = opt
end
opts.on('--lock-force', 'Force the removal of an existing lockfile.  Normally lockfile is removed if over 2 hours old.') do |opt|
  @lockforce = opt
end
opts.on('--use-ssh-key', 'Use ssh key for deploying instead of prompting for ssh password') do |opt|
  @deploy_options["use-ssh-key"] = opt
  @deploy_params = @deploy_params - ['--use-ssh-key']
end
opts.on('--deploy-as', '=USERNAME', 'What username to use for deploying to remote server') do |opt|
  @deploy_options["deploy-as"] = opt
  @deploy_params = @deploy_params - ['--deploy-as']
end
opts.on('--debug', 'Print lots of messages about what tpkg is doing') do |opt|
  @debug = opt
  Tpkg::set_debug(@debug)
end
opts.on('--version', 'Show tpkg version') do |opt|
  puts Tpkg::VERSION
  exit
end
opts.on_tail("-h", "--help", "Show this message") do
  puts opts
  exit
end

opts.parse(ARGV)

# Rerun with sudo if necessary, unless it's a deploy, then
# we don't need to run with sudo on this machine. It will run with sudo
# on the remote machine
if @rerun_with_sudo && !@deploy
  rerun_with_sudo_if_necessary
end

# Display a usage message if the user did not specify a valid action to perform.
if !@action
  puts opts
  exit
end

#
# Figure out base directory, sources and other configuration
#

def instantiate_tpkg
  base = Tpkg::DEFAULT_BASE
  sources = []
  report_server = nil
  
  ['/etc/tpkg.conf', "#{ENV['HOME']}/.tpkg.conf"].each do |configfile|
    if File.exist?(configfile)
      IO.foreach(configfile) do |line|
        line.chomp!
        next if (line =~ /^\s*$/);  # Skip blank lines
        next if (line =~ /^\s*#/);  # Skip comments
        key, value = line.split(/\s*=\s*/, 2)
        if key == 'base'
          # Warn the user, as this could potentially be confusing
          # if they don't realize there's a config file lying
          # around
          base = value
          warn "Using base #{base} from #{configfile}"
        elsif key == 'source'
          sources << value
          puts "Loaded source #{value} from #{configfile}" if (@debug)
        elsif key == 'report_server'
          report_server = value
          puts "Loaded report server #{report_server} from #{configfile}" if (@debug)
        end
      end
    end
  end
  
  if ENV['TPKG_HOME']
    base = ENV['TPKG_HOME']
    # Warn the user, as this could potentially be confusing
    # if they don't realize there's an environment variable set.
    warn "Using base '#{base}' base from $TPKG_HOME"
  end
  
  tpkg = Tpkg.new(:base => base, :sources => sources, :report_server => report_server, :lockforce => @lockforce)
end

passphrase_callback = lambda do | package |
  ask("Passphrase for #{package}: ") { |q| q.echo = "*"}
#  print "Passphrase for #{package}: "
#  $stdin.gets.chomp
end

#
# Do stuff
#
if @deploy
#  puts "Creating deployer with #{@worker_count} number of worker"
  @deploy_options["worker-count"] = @worker_count
  @deploy_options["abort-on-fail"] = false
  Tpkg::deploy(@deploy_params, @deploy_options,  @servers) 
  exit
end

case @action
when :make
  pkgfile = Tpkg::make_package(@action_value, passphrase_callback)
  puts "Package is #{pkgfile}"
when :extract
  Tpkg::extract_metadata(@action_value)
when :install
  tpkg = instantiate_tpkg
  tpkg.install(@action_value, passphrase_callback)
when :upgrade
  tpkg = instantiate_tpkg
  tpkg.upgrade(@action_value, passphrase_callback)
when :remove
  tpkg = instantiate_tpkg
  tpkg.remove(@action_value)
when :verify
  result = nil
  # Verify a given .tpkg file
  if File.exist?(@action_value)
    Tpkg::verify_package_checksum(@action_value)
  # Verify an installed pkg
  else
    tpkg = instantiate_tpkg
    results = tpkg.verify_file_metadata(@action_value)
    if results.length == 0
      puts "No package found"
    end
    success = true
    results.each do | file, errors |
      if errors.length == 0
        puts "#{file}: Passed"
      else
        puts "#{file}: Failed (Reasons: #{errors.join(", ")})"
        success = false
      end
    end 
    puts "Package verification failed" unless success 
  end
when :start_init
  tpkg = instantiate_tpkg
  tpkg.execute_init(@action_value, "start")
when :stop_init
  tpkg = instantiate_tpkg
  tpkg.execute_init(@action_value, "stop")
when :restart_init
  tpkg = instantiate_tpkg
  tpkg.execute_init(@action_value, "restart")
when :query_installed
  tpkg = instantiate_tpkg
  req = nil
  if @action_value
    req = Tpkg::parse_request(@action_value)
  end
  matches = tpkg.installed_packages_that_meet_requirement(req)
  if matches.empty?
    # If the user requested a specific package and we found no matches
    # then exit with a non-zero value to indicate failure.  This allows
    # command-line syntax like "tpkg -q foo || tpkg -i foo" to ensure
    # that a package is installed.
    if @action_value
      exit(false)
    end
  else
    if !@quiet
      matches.each do |pkg|
        puts pkg[:metadata][:filename]
      end
    end
  end
when :query_info
  metadatas = nil
  if File.exist?(@action_value)
    metadatas = [Tpkg::metadata_xml_to_hash(Tpkg::metadata_from_package(@action_value))]
  else
    tpkg = instantiate_tpkg
    metadatas = tpkg.installed_packages_that_meet_requirement(Tpkg::parse_request(@action_value)).collect { |pkg| pkg[:metadata] }
  end
  metadatas.each do |metadata|
    [:name, :version, :package_version, :operatingsystem, :architecture, :maintainer, :description, :bugreporting].each do |field|
      if metadata[field]
        puts "#{field}: #{metadata[field]}"
      end
    end
  end
when :query_list_files
  tpkg = instantiate_tpkg
  pkgfiles = nil
  if File.exist?(@action_value)
    fip = Tpkg::files_in_package(@action_value)
    tpkg.normalize_paths(fip)
    puts "#{pkgfile}:"
    fip[:normalized].each { |file| puts file }
  else
    pkgfiles = tpkg.installed_packages_that_meet_requirement(Tpkg::parse_request(@action_value)).collect { |pkg| pkg[:metadata][:filename] }
    files = tpkg.files_for_installed_packages(pkgfiles)
    files.each do |pkgfile, fip|
      puts "#{pkgfile}:"
      fip[:normalized].each { |file| puts file }
    end
  end
when :query_who_owns_file
  tpkg = instantiate_tpkg
  tpkg.files_for_installed_packages.each do |pkgfile, fip|
    fip[:normalized].each do |file|
      if file == @action_value
        puts "#{file}: #{pkgfile}"
      end
    end
  end
when :query_available
  tpkg = instantiate_tpkg
  req = nil
  if @action_value
    req = Tpkg::parse_request(@action_value)
  end
  tpkg.available_packages_that_meet_requirement(req).each do |pkg|
    next if pkg[:source] == :native_installed
    next if pkg[:source] == :native_available
    puts "#{pkg[:metadata][:filename]} (#{pkg[:source]})"
  end
when :query_requires
  tpkg = instantiate_tpkg
  tpkg.metadata_for_installed_packages.each do |metadata|
    if metadata[:dependencies].any? { |req| req[:name] == @action_value}
      puts metadata[:filename]
    end
  end
when :query_depends
  tpkg = instantiate_tpkg
  requirements = []
  packages = {}
  tpkg.parse_requests([@action_value], requirements, packages)
  packages.each do |name, pkgs|
    already_displayed = {}
    pkgs.each do |pkg|
      # parse_requests returns both installed and available packages.
      # The same package may show up in both, skip any duplicates.
      next if already_displayed[pkg[:filename]]
      already_displayed[pkg[:filename]] = true
      puts pkg[:metadata][:filename] + ':'
      if pkg[:metadata][:dependencies]
        pkg[:metadata][:dependencies].each do |req|
          puts "  Requires #{req[:name]}"
          req.each do |field, value|
            next if field == :name
            puts "    #{field}: #{value}"
          end
        end
      end
    end
  end
end

