#!/usr/bin/ruby -w
##############################################################################
# tpkg package management and deployment tool
##############################################################################

# Ensure we can find tpkg.rb
$:.unshift File.dirname(__FILE__)

require 'optparse'
require 'tpkg'

#
# Parse the command line options
#

@action = nil
@action_value = nil
@debug = false
@prompt = true
@quiet = false
@sudo = true
@lockforce = false
@servers = nil
@worker_count = 4

def rerun_with_sudo_if_necessary
  if Process.euid != 0 && @sudo
    warn "Executing with sudo"
    exec('sudo', $0, *ARGV)
  end
end

opts = OptionParser.new
opts.banner = 'Usage: tpkg [options]'
opts.on('--servers', '-s', '=SERVERS', Array, 'Servers to apply the actions to. Currently supports install and remove') do |opt|
  @servers = opt
end
opts.on('--make', '-m', '=DIRECTORY', 'Make a package out of the contents of the directory') do |opt|
  @action = :make
  @action_value = opt
end
opts.on('--extract', '-x', '=DIRECTORY', 'Extract the metadata for a directory of packages') do |opt|
  @action = :extract
  @action_value = opt
end
opts.on('--install', '-i', '=PACKAGES', 'Install one or more packages', Array) do |opt|
  rerun_with_sudo_if_necessary
  @action = :install
  @action_value = opt
end
opts.on('--upgrade', '-u', '=PACKAGES', 'Upgrade one or more packages', Array) do |opt|
  rerun_with_sudo_if_necessary
  @action = :upgrade
  @action_value = opt
end
opts.on('--remove', '-r', '=PACKAGES', 'Remove one or more packages', Array) do |opt|
  rerun_with_sudo_if_necessary
  @action = :remove
  @action_value = opt
end
opts.on('--verify', '-V', '=NAME', 'Verify installed packages') do |opt|
  rerun_with_sudo_if_necessary
  @action = :verify
  @action_value = opt
end
opts.on('--start', '=NAME', 'Start the init script for the specified package') do |opt|
  rerun_with_sudo_if_necessary
  @action = :start_init
  @action_value = opt
end
opts.on('--stop', '=NAME', 'Stop the init script for the specified package') do |opt|
  rerun_with_sudo_if_necessary
  @action = :stop_init
  @action_value = opt
end
opts.on('--restart', '=NAME', 'Restart the init script for the specified package') do |opt|
  rerun_with_sudo_if_necessary
  @action = :restart_init
  @action_value = opt
end
opts.on('--query', '-q', '=NAME', 'List installed packages') do |opt|
  @action = :query_installed
  @action_value = opt
end
opts.on('--qa', 'List all installed packages') do |opt|
  @action = :query_installed
end
opts.on('--qi', '=NAME', 'Info for installed packages') do |opt|
  @action = :query_info
  @action_value = opt
end
opts.on('--ql', '=NAME', 'List files in installed packages') do |opt|
  @action = :query_list_files
  @action_value = opt
end
opts.on('--qf', '=NAME', 'List the package that owns a file') do |opt|
  @action = :query_who_owns_file
  @action_value = opt
end
opts.on('--qv', '[NAME]', 'List available packages') do |opt|
  @action = :query_available
  # Since the argument is optional OptionParser will pass true in opt if
  # the option was specified without an argument.  We only want to capture
  # the argument if the user actually passed something.
  if opt != true
    @action_value = opt
  end
end
opts.on('--qr', '=NAME', 'List installed packages that require package') do |opt|
  @action = :query_requires
  @action_value = opt
end
opts.on('--qd', '=NAME', 'List the packages that package depends on') do |opt|
  @action = :query_depends
  @action_value = opt
end
opts.on('-n', '--no-prompt', 'No confirmation prompts regarding file conflicts or package removals') do |opt|
  @prompt = opt
  Tpkg::set_prompt(@prompt)
end
opts.on('--quiet', 'Reduce or eliminate informative but non-essential output') do |opt|
  @quiet = opt
end
opts.on('--no-sudo', 'No calls to sudo for operations that might need root privileges') do |opt|
  @sudo = opt
end
opts.on('--lock-force', 'Force the removal of an existing lockfile.  Normally lockfile is removed if over 2 hours old.') do |opt|
  @lockforce = opt
end
opts.on('--debug', 'Print lots of messages about what tpkg is doing') do |opt|
  @debug = opt
  Tpkg::set_debug(@debug)
end
opts.on_tail("-h", "--help", "Show this message") do
  puts opts
  exit
end

opts.parse(ARGV)

# Display a usage message if the user did not specify a valid action to perform.
if !@action
  puts opts
  exit
end

#
# Figure out base directory, sources and other configuration
#

def instantiate_tpkg
  base = Tpkg::DEFAULT_BASE
  sources = []
  report_server = nil
  
  ['/etc/tpkg.conf', "#{ENV['HOME']}/.tpkg.conf"].each do |configfile|
    if File.exist?(configfile)
      IO.foreach(configfile) do |line|
        line.chomp!
        next if (line =~ /^\s*$/);  # Skip blank lines
        next if (line =~ /^\s*#/);  # Skip comments
        key, value = line.split(/\s*=\s*/, 2)
        if key == 'base'
          # Warn the user, as this could potentially be confusing
          # if they don't realize there's a config file lying
          # around
          base = value
          warn "Using base #{base} from #{configfile}"
        elsif key == 'source'
          sources << value
          puts "Loaded source #{value} from #{configfile}" if (@debug)
        elsif key == 'report_server'
          report_server = value
          puts "Loaded report server #{report_server} from #{configfile}" if (@debug)
        end
      end
    end
  end
  
  if ENV['TPKG_HOME']
    base = ENV['TPKG_HOME']
    # Warn the user, as this could potentially be confusing
    # if they don't realize there's an environment variable set.
    warn "Using base '#{base}' base from $TPKG_HOME"
  end
  
  tpkg = Tpkg.new(:base => base, :sources => sources, :report_server => report_server, :lockforce => @lockforce)
end

passphrase_callback = lambda do | package |
  print "Passphrase for #{package}: "
  $stdin.gets.chomp
end

#
# Do stuff
#

case @action
when :deploy
  puts "Deploying #{@action_value} to #{@servers.inspect}"
when :make
  pkgfile = Tpkg::make_package(@action_value, passphrase_callback)
  puts "Package is #{pkgfile}"
when :extract
  Tpkg::extract_metadata(@action_value)
when :install
  tpkg = instantiate_tpkg
  if @servers.nil?
    tpkg.install(@action_value, passphrase_callback)
  else
    tpkg.deploy_install(@action_value, false, @worker_count, @servers)
  end
when :upgrade
  tpkg = instantiate_tpkg
  if @servers.nil?
    tpkg.upgrade(@action_value, passphrase_callback)
  else
    tpkg.deploy_upgrade(@action_value, false, @worker_count, @servers)
  end
when :remove
  tpkg = instantiate_tpkg
  if @servers.nil?
    tpkg.remove(@action_value)
  else
    tpkg.deploy_remove(@action_value, false, @worker_count, @servers)
  end
when :verify
  result = nil
  tpkg = instantiate_tpkg
  results = tpkg.verify_file_metadata(@action_value)
  if results.length == 0
    puts "No package found"
  end
  success = true
  results.each do | file, errors |
    if errors.length == 0
      puts "#{file}: Passed"
    else
      puts "#{file}: Failed (Reasons: #{errors.join(", ")})"
      success = false
    end
  end 
  puts "Package verification failed" unless success 
when :start_init
  tpkg = instantiate_tpkg
  if @servers.nil?
    tpkg.execute_init(@action_value, "start")
  else
    tpkg.deploy_start(@action_value, false, @worker_count, @servers)
  end
when :stop_init
  tpkg = instantiate_tpkg
  if @servers.nil?
    tpkg.execute_init(@action_value, "stop")
  else
    tpkg.deploy_stop(@action_value, false, @worker_count, @servers)
  end
when :restart_init
  tpkg = instantiate_tpkg
  if @servers.nil?
    tpkg.execute_init(@action_value, "restart")
  else
    tpkg.deploy_restart(@action_value, false, @worker_count, @servers)
  end
when :query_installed
  tpkg = instantiate_tpkg
  req = nil
  if @action_value
    req = Tpkg::parse_request(@action_value)
  end
  matches = tpkg.installed_packages_that_meet_requirement(req)
  if matches.empty?
    # If the user requested a specific package and we found no matches
    # then exit with a non-zero value to indicate failure.  This allows
    # command-line syntax like "tpkg -q foo || tpkg -i foo" to ensure
    # that a package is installed.
    if @action_value
      exit(false)
    end
  else
    if !@quiet
      matches.each do |pkg|
        puts pkg[:metadata].root.attributes['filename']
      end
    end
  end
when :query_info
  metadatas = nil
  if File.exist?(@action_value)
    metadatas = [Tpkg::metadata_from_package(@action_value)]
  else
    tpkg = instantiate_tpkg
    metadatas = tpkg.installed_packages_that_meet_requirement(Tpkg::parse_request(@action_value)).collect { |pkg| pkg[:metadata] }
  end
  metadatas.each do |metadata|
    ['name', 'version', 'package_version', 'operatingsystem', 'architecture', 'maintainer', 'description', 'bugreporting'].each do |field|
      if metadata.elements["/tpkg/#{field}"]
        puts "#{field}: #{metadata.elements["/tpkg/#{field}"].text}"
      end
    end
  end
when :query_list_files
  tpkg = instantiate_tpkg
  pkgfiles = nil
  if File.exist?(@action_value)
    fip = Tpkg::files_in_package(@action_value)
    tpkg.normalize_paths(fip)
    puts "#{pkgfile}:"
    fip[:normalized].each { |file| puts file }
  else
    pkgfiles = tpkg.installed_packages_that_meet_requirement(Tpkg::parse_request(@action_value)).collect { |pkg| pkg[:metadata].root.attributes['filename'] }
    files = tpkg.files_for_installed_packages(pkgfiles)
    files.each do |pkgfile, fip|
      puts "#{pkgfile}:"
      fip[:normalized].each { |file| puts file }
    end
  end
when :query_who_owns_file
  tpkg = instantiate_tpkg
  tpkg.files_for_installed_packages.each do |pkgfile, fip|
    fip[:normalized].each do |file|
      if file == @action_value
        puts "#{file}: #{pkgfile}"
      end
    end
  end
when :query_available
  tpkg = instantiate_tpkg
  req = nil
  if @action_value
    req = Tpkg::parse_request(@action_value)
  end
  tpkg.available_packages_that_meet_requirement(req) do |pkg|
    puts "#{pkg[:metadata].root.attributes['filename']} (#{pkg[:source]})"
  end
when :query_requires
  tpkg = instantiate_tpkg
  tpkg.metadata_for_installed_packages.each do |metadata|
    reqs = Tpkg::extract_reqs_from_metadata(metadata)
    if reqs.any? { |req| req[:name] == @action_value}
      puts metadata.root.attributes['filename']
    end
  end
when :query_depends
  tpkg = instantiate_tpkg
  tpkg.installed_packages_that_meet_requirement(Tpkg::parse_request(@action_value)).each do |pkg|
    Tpkg::extract_reqs_from_metadata(pkg[:metadata]).each do |req|
      puts "Requires #{req[:name]}"
      req.each do |field, value|
        next if field == :name
        puts "#{field}: #{value}"
      end
    end
  end
end

